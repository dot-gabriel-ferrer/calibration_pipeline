# -*- coding: utf-8 -*-
"""Comparative analysis of bias and dark frames across radiation stages.

This script builds upon ``process_index.py`` and ``operation_analysis.py`` to
compute master bias and dark frames for the *pre*, *radiating* and *post*
irradiation stages.  During the radiating stage the frames are additionally
split by the mean radiation level indicated in ``radiationLogCompleto.csv``.

For each selected dataset the script generates:

- Master bias and dark frames grouped by temperature.
- CSV tables summarising mean and standard deviation per frame and per group.
- Heatmaps showing the difference between stages.
- Temporal variation plots of the frame mean vs. timestamp and radiation level.

The input is the ``index.csv`` generated by ``run_calibration.py`` together with
its ``radiationLogCompleto.csv`` file.  Only FITS files flagged as valid
(``BADFITS == False``) are processed.
"""
from __future__ import annotations

import argparse
import os
import re
from collections import defaultdict
from itertools import combinations
from typing import Dict, Iterable, List, Tuple

import numpy as np
import pandas as pd
from astropy.io import fits
import matplotlib.pyplot as plt

from process_index import _make_mean_master
from operation_analysis import _parse_rads


# -----------------------------------------------------------------------------
# Radiation log utilities
# -----------------------------------------------------------------------------

def _load_radiation_log(path: str) -> pd.DataFrame:
    """Load ``radiationLogCompleto.csv`` as a ``DataFrame``.

    Parameters
    ----------
    path : str
        Path to the CSV file.

    Returns
    -------
    pandas.DataFrame
        Empty ``DataFrame`` if the file does not exist or cannot be read.
    """
    if not os.path.isfile(path):
        return pd.DataFrame()
    try:
        return pd.read_csv(path)
    except Exception:
        return pd.DataFrame()


def _split_log_by_frame_reset(df: pd.DataFrame) -> List[pd.DataFrame]:
    """Split the log whenever ``FrameNum`` decreases or resets."""
    if df.empty or "FrameNum" not in df.columns:
        return []
    frames = pd.to_numeric(df["FrameNum"], errors="coerce").astype("Int64")
    groups = []
    start = 0
    for i in range(1, len(frames)):
        if frames.iloc[i] <= frames.iloc[i - 1]:
            groups.append(df.iloc[start:i])
            start = i
    groups.append(df.iloc[start:])
    return groups


def _mean_radiation(df: pd.DataFrame) -> float:
    """Return the mean radiation level or dose for ``df``."""
    for col in ("RadiationLevel", "Dose"):
        if col in df.columns:
            return float(pd.to_numeric(df[col], errors="coerce").mean())
    return float("nan")


# -----------------------------------------------------------------------------
# Frame loading helpers
# -----------------------------------------------------------------------------

def _load_frame(path: str) -> Tuple[np.ndarray, fits.Header]:
    with fits.open(path) as hdul:
        return hdul[0].data.astype(np.float32), hdul[0].header


def _extract_rads_from_path(path: str) -> float | None:
    for part in path.split(os.sep):
        val = _parse_rads(part)
        if val is not None:
            return val
    return None


# -----------------------------------------------------------------------------
# Master generation
# -----------------------------------------------------------------------------

def master_by_temp(
    paths: List[str],
    temps: List[float],
    bias_maps: Dict[float, np.ndarray] | None = None,
) -> Dict[float, np.ndarray]:
    """Compute mean master frames grouped by temperature.

    If ``bias_maps`` is provided the bias map with the closest temperature is
    subtracted from each frame before combining.
    """
    temp_groups: Dict[float, List[str]] = defaultdict(list)
    for p, t in zip(paths, temps):
        if t is None or not np.isfinite(t):
            continue
        temp_groups[float(t)].append(p)

    masters: Dict[float, np.ndarray] = {}
    for temp, files in temp_groups.items():
        arrays: List[np.ndarray] = []
        for f in files:
            data = fits.getdata(f).astype(np.float32)
            if bias_maps:
                btemp = min(bias_maps.keys(), key=lambda bt: abs(bt - temp))
                data = data - bias_maps[btemp]
            arrays.append(data)
        stack = np.stack(arrays, axis=0)
        masters[temp] = np.mean(stack, axis=0)
    return masters


# -----------------------------------------------------------------------------
# Analysis functions
# -----------------------------------------------------------------------------

def analyse_stage(df: pd.DataFrame, log_path: str, outdir: str, stage: str) -> None:
    """Analyse all bias and dark frames belonging to one radiation stage."""
    os.makedirs(outdir, exist_ok=True)
    stage_df = df[df["STAGE"] == stage]
    if stage_df.empty:
        return

    bias_df = stage_df[stage_df["CALTYPE"] == "BIAS"]
    dark_df = stage_df[stage_df["CALTYPE"] == "DARK"]

    log_df = _load_radiation_log(log_path)
    log_groups = _split_log_by_frame_reset(log_df)

    # Map frame numbers to radiation groups
    frame_to_group: Dict[int, int] = {}
    rad_means: Dict[int, float] = {}
    for idx, g in enumerate(log_groups):
        frames = pd.to_numeric(g["FrameNum"], errors="coerce").astype("Int64")
        rad = _mean_radiation(g)
        rad_means[idx] = rad
        for f in frames.dropna().astype(int):
            frame_to_group[f] = idx

    summary_rows = []

    # Compute bias masters first
    bias_masters: Dict[float, np.ndarray] = {}
    if not bias_df.empty:
        b_paths = list(bias_df["PATH"])
        b_temps = [fits.getheader(p).get("TEMP") for p in b_paths]
        means: List[float] = []
        stds: List[float] = []
        frames: List[int] = []
        groups: List[int] = []
        for p in b_paths:
            data, hdr = _load_frame(p)
            means.append(float(np.mean(data)))
            stds.append(float(np.std(data)))
            frames.append(hdr.get("FRAMENUM"))
            groups.append(frame_to_group.get(hdr.get("FRAMENUM"), -1))
        out_csv = os.path.join(outdir, "stats_bias.csv")
        pd.DataFrame(
            {
                "PATH": b_paths,
                "FRAME": frames,
                "GROUP": groups,
                "TEMP": b_temps,
                "MEAN": means,
                "STD": stds,
            }
        ).to_csv(out_csv, index=False)

        bias_masters = master_by_temp(b_paths, b_temps)
        for t, master in bias_masters.items():
            fpath = os.path.join(outdir, f"master_bias_T{t:.1f}.fits")
            fits.writeto(fpath, master.astype(np.float32), overwrite=True)

        for g_id in sorted(set(groups)):
            if g_id < 0:
                continue
            mask = [g == g_id for g in groups]
            if not any(mask):
                continue
            summary_rows.append(
                {
                    "STAGE": stage,
                    "CALTYPE": "BIAS",
                    "GROUP": g_id,
                    "MEAN_RAD": rad_means.get(g_id, float("nan")),
                    "MEAN_VAL": float(np.mean([m for m, ok in zip(means, mask) if ok])),
                    "STD_VAL": float(np.mean([s for s, ok in zip(stds, mask) if ok])),
                }
            )

    # Analyse dark frames subtracting bias
    if not dark_df.empty:
        d_paths = list(dark_df["PATH"])
        d_temps = [fits.getheader(p).get("TEMP") for p in d_paths]
        means: List[float] = []
        stds: List[float] = []
        frames: List[int] = []
        groups: List[int] = []
        for p, t in zip(d_paths, d_temps):
            data, hdr = _load_frame(p)
            if bias_masters:
                btemp = min(bias_masters.keys(), key=lambda bt: abs(bt - t))
                data = data - bias_masters[btemp]
            means.append(float(np.mean(data)))
            stds.append(float(np.std(data)))
            frames.append(hdr.get("FRAMENUM"))
            groups.append(frame_to_group.get(hdr.get("FRAMENUM"), -1))
        out_csv = os.path.join(outdir, "stats_dark.csv")
        pd.DataFrame(
            {
                "PATH": d_paths,
                "FRAME": frames,
                "GROUP": groups,
                "TEMP": d_temps,
                "MEAN": means,
                "STD": stds,
            }
        ).to_csv(out_csv, index=False)

        masters = master_by_temp(d_paths, d_temps, bias_maps=bias_masters)
        for t, master in masters.items():
            fpath = os.path.join(outdir, f"master_dark_T{t:.1f}.fits")
            fits.writeto(fpath, master.astype(np.float32), overwrite=True)

        for g_id in sorted(set(groups)):
            if g_id < 0:
                continue
            mask = [g == g_id for g in groups]
            if not any(mask):
                continue
            summary_rows.append(
                {
                    "STAGE": stage,
                    "CALTYPE": "DARK",
                    "GROUP": g_id,
                    "MEAN_RAD": rad_means.get(g_id, float("nan")),
                    "MEAN_VAL": float(np.mean([m for m, ok in zip(means, mask) if ok])),
                    "STD_VAL": float(np.mean([s for s, ok in zip(stds, mask) if ok])),
                }
            )

    if summary_rows:
        pd.DataFrame(summary_rows).to_csv(os.path.join(outdir, "group_summary.csv"), index=False)


# -----------------------------------------------------------------------------
# Difference heatmaps and temporal plots
# -----------------------------------------------------------------------------

def diff_heatmap(ref_master: np.ndarray, target_master: np.ndarray, outpath: str, title: str) -> None:
    diff = target_master - ref_master
    plt.figure(figsize=(6, 5))
    im = plt.imshow(diff, origin="lower", cmap="seismic")
    plt.colorbar(im, label="ADU")
    plt.title(title)
    plt.tight_layout()
    plt.savefig(outpath)
    plt.close()

    # Save the difference array alongside the PNG
    np.savez_compressed(os.path.splitext(outpath)[0] + ".npz", diff=diff)


# -----------------------------------------------------------------------------
# Command line interface
# -----------------------------------------------------------------------------

def main(index_csv: str, radiation_log: str, output_dir: str, stages: Iterable[str]) -> None:
    df = pd.read_csv(index_csv)
    df = df[df.get("BADFITS", False) == False]

    os.makedirs(output_dir, exist_ok=True)

    for stage in stages:
        out = os.path.join(output_dir, stage)
        analyse_stage(df, radiation_log, out, stage)

    # Generate difference heatmaps between all available stage pairs
    stage_dirs = {s: os.path.join(output_dir, s) for s in stages}
    for s1, s2 in combinations(stages, 2):
        dir1, dir2 = stage_dirs[s1], stage_dirs[s2]
        if not (os.path.isdir(dir1) and os.path.isdir(dir2)):
            continue
        for fname in os.listdir(dir1):
            if not (fname.startswith("master_bias") or fname.startswith("master_dark")):
                continue
            ref_path = os.path.join(dir1, fname)
            targ_path = os.path.join(dir2, fname)
            if os.path.isfile(targ_path):
                ref = fits.getdata(ref_path)
                targ = fits.getdata(targ_path)
                outname = f"{os.path.splitext(fname)[0]}_{s2}_minus_{s1}.png"
                title = f"Diff {s2}-{s1} {fname}"
                diff_heatmap(ref, targ, os.path.join(output_dir, outname), title)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyse bias/dark frames across radiation stages")
    parser.add_argument("index_csv", help="Path to index.csv generated by run_calibration")
    parser.add_argument("radiation_log", help="Path to radiationLogCompleto.csv")
    parser.add_argument("output_dir", help="Directory for analysis outputs")
    parser.add_argument(
        "--stages",
        nargs="*",
        default=["pre", "radiating", "post"],
        help="Stages to analyse (pre, radiating, post)",
    )
    args = parser.parse_args()
    main(args.index_csv, args.radiation_log, args.output_dir, args.stages)
