# -*- coding: utf-8 -*-
"""Comparative analysis of bias and dark frames across radiation stages.

This script builds upon ``process_index.py`` and ``operation_analysis.py`` to
compute master bias and dark frames for the *pre*, *during* and *post*
irradiation stages.  During the radiation stage the frames are additionally
split by the mean radiation level indicated in ``radiationLogCompleto.csv``.

For each selected dataset the script generates:

- Master bias and dark frames grouped by temperature.
- CSV tables summarising mean and standard deviation per frame and per group.
- Heatmaps showing the difference between stages.
- Temporal variation plots of the frame mean vs. timestamp and radiation level.

The input is the ``index.csv`` generated by ``run_calibration.py`` together with
its ``radiationLogCompleto.csv`` file.  Only FITS files flagged as valid
(``BADFITS == False``) are processed.
"""
from __future__ import annotations

import argparse
import os
import re
from collections import defaultdict
from typing import Dict, Iterable, List, Tuple

import numpy as np
import pandas as pd
from astropy.io import fits
import matplotlib.pyplot as plt

from process_index import _make_mean_master
from operation_analysis import _parse_rads


# -----------------------------------------------------------------------------
# Radiation log utilities
# -----------------------------------------------------------------------------

def _load_radiation_log(path: str) -> pd.DataFrame:
    """Load ``radiationLogCompleto.csv`` as a ``DataFrame``.

    Parameters
    ----------
    path : str
        Path to the CSV file.

    Returns
    -------
    pandas.DataFrame
        Empty ``DataFrame`` if the file does not exist or cannot be read.
    """
    if not os.path.isfile(path):
        return pd.DataFrame()
    try:
        return pd.read_csv(path)
    except Exception:
        return pd.DataFrame()


def _split_log_by_frame_reset(df: pd.DataFrame) -> List[pd.DataFrame]:
    """Split the log whenever ``FrameNum`` decreases or resets."""
    if df.empty or "FrameNum" not in df.columns:
        return []
    frames = pd.to_numeric(df["FrameNum"], errors="coerce").astype("Int64")
    groups = []
    start = 0
    for i in range(1, len(frames)):
        if frames.iloc[i] <= frames.iloc[i - 1]:
            groups.append(df.iloc[start:i])
            start = i
    groups.append(df.iloc[start:])
    return groups


def _mean_radiation(df: pd.DataFrame) -> float:
    """Return the mean radiation level or dose for ``df``."""
    for col in ("RadiationLevel", "Dose"):
        if col in df.columns:
            return float(pd.to_numeric(df[col], errors="coerce").mean())
    return float("nan")


# -----------------------------------------------------------------------------
# Frame loading helpers
# -----------------------------------------------------------------------------

def _load_frame(path: str) -> Tuple[np.ndarray, fits.Header]:
    with fits.open(path) as hdul:
        return hdul[0].data.astype(np.float32), hdul[0].header


def _extract_rads_from_path(path: str) -> float | None:
    for part in path.split(os.sep):
        val = _parse_rads(part)
        if val is not None:
            return val
    return None


# -----------------------------------------------------------------------------
# Master generation
# -----------------------------------------------------------------------------

def master_by_temp(paths: List[str], temps: List[float]) -> Dict[float, np.ndarray]:
    """Compute mean master frames grouped by temperature."""
    temp_groups: Dict[float, List[str]] = defaultdict(list)
    for p, t in zip(paths, temps):
        if t is None or not np.isfinite(t):
            continue
        temp_groups[float(t)].append(p)

    masters: Dict[float, np.ndarray] = {}
    for temp, files in temp_groups.items():
        master, _ = _make_mean_master(files, temps=[temp] * len(files))
        masters[temp] = master
    return masters


# -----------------------------------------------------------------------------
# Analysis functions
# -----------------------------------------------------------------------------

def analyse_stage(df: pd.DataFrame, log_path: str, outdir: str, stage: str) -> None:
    """Analyse all bias and dark frames belonging to one radiation stage."""
    os.makedirs(outdir, exist_ok=True)
    stage_df = df[df["STAGE"] == stage]
    if stage_df.empty:
        return

    bias_df = stage_df[stage_df["CALTYPE"] == "BIAS"]
    dark_df = stage_df[stage_df["CALTYPE"] == "DARK"]

    log_df = _load_radiation_log(log_path)
    log_groups = _split_log_by_frame_reset(log_df)

    # Map frame numbers to radiation groups
    frame_to_group: Dict[int, int] = {}
    rad_means: Dict[int, float] = {}
    for idx, g in enumerate(log_groups):
        frames = pd.to_numeric(g["FrameNum"], errors="coerce").astype("Int64")
        rad = _mean_radiation(g)
        rad_means[idx] = rad
        for f in frames.dropna().astype(int):
            frame_to_group[f] = idx

    summary_rows = []

    for caltype, subdf in (("BIAS", bias_df), ("DARK", dark_df)):
        if subdf.empty:
            continue
        means: List[float] = []
        stds: List[float] = []
        temps: List[float] = []
        frames: List[int] = []
        paths: List[str] = []
        groups: List[int] = []
        for p in subdf["PATH"]:
            data, hdr = _load_frame(p)
            means.append(float(np.mean(data)))
            stds.append(float(np.std(data)))
            temps.append(hdr.get("TEMP"))
            frames.append(hdr.get("FRAMENUM"))
            paths.append(p)
            groups.append(frame_to_group.get(hdr.get("FRAMENUM"), -1))
        out_csv = os.path.join(outdir, f"stats_{caltype.lower()}.csv")
        pd.DataFrame(
            {
                "PATH": paths,
                "FRAME": frames,
                "GROUP": groups,
                "TEMP": temps,
                "MEAN": means,
                "STD": stds,
            }
        ).to_csv(out_csv, index=False)

        masters = master_by_temp(paths, temps)
        for t, master in masters.items():
            fpath = os.path.join(outdir, f"master_{caltype.lower()}_T{t:.1f}.fits")
            fits.writeto(fpath, master.astype(np.float32), overwrite=True)

        # store group summary
        for g_id in sorted(set(groups)):
            if g_id < 0:
                continue
            mask = [g == g_id for g in groups]
            if not any(mask):
                continue
            summary_rows.append(
                {
                    "STAGE": stage,
                    "CALTYPE": caltype,
                    "GROUP": g_id,
                    "MEAN_RAD": rad_means.get(g_id, float("nan")),
                    "MEAN_VAL": float(np.mean([m for m, ok in zip(means, mask) if ok])),
                    "STD_VAL": float(np.mean([s for s, ok in zip(stds, mask) if ok])),
                }
            )

    if summary_rows:
        pd.DataFrame(summary_rows).to_csv(os.path.join(outdir, "group_summary.csv"), index=False)


# -----------------------------------------------------------------------------
# Difference heatmaps and temporal plots
# -----------------------------------------------------------------------------

def diff_heatmap(ref_master: np.ndarray, target_master: np.ndarray, outpath: str, title: str) -> None:
    diff = target_master - ref_master
    plt.figure(figsize=(6, 5))
    im = plt.imshow(diff, origin="lower", cmap="seismic")
    plt.colorbar(im, label="ADU")
    plt.title(title)
    plt.tight_layout()
    plt.savefig(outpath)
    plt.close()


# -----------------------------------------------------------------------------
# Command line interface
# -----------------------------------------------------------------------------

def main(index_csv: str, radiation_log: str, output_dir: str, stages: Iterable[str]) -> None:
    df = pd.read_csv(index_csv)
    df = df[df.get("BADFITS", False) == False]

    os.makedirs(output_dir, exist_ok=True)

    for stage in stages:
        out = os.path.join(output_dir, stage)
        analyse_stage(df, radiation_log, out, stage)

    # If both pre and during stages exist, generate difference heatmaps
    pre_dir = os.path.join(output_dir, "pre")
    during_dir = os.path.join(output_dir, "during")
    if os.path.isdir(pre_dir) and os.path.isdir(during_dir):
        for fname in os.listdir(pre_dir):
            if not fname.startswith("master_bias"):
                continue
            ref = fits.getdata(os.path.join(pre_dir, fname))
            targ_path = os.path.join(during_dir, fname)
            if os.path.isfile(targ_path):
                targ = fits.getdata(targ_path)
                outname = os.path.splitext(fname)[0] + "_diff.png"
                diff_heatmap(ref, targ, os.path.join(output_dir, outname), f"Diff {fname}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Analyse bias/dark frames across radiation stages")
    parser.add_argument("index_csv", help="Path to index.csv generated by run_calibration")
    parser.add_argument("radiation_log", help="Path to radiationLogCompleto.csv")
    parser.add_argument("output_dir", help="Directory for analysis outputs")
    parser.add_argument(
        "--stages",
        nargs="*",
        default=["pre", "during", "post"],
        help="Stages to analyse (pre, during, post)",
    )
    args = parser.parse_args()
    main(args.index_csv, args.radiation_log, args.output_dir, args.stages)
